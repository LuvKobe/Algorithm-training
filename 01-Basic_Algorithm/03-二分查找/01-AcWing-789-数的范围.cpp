/*
题目链接：https://www.acwing.com/problem/content/791/

1. 题目解释：

对于在一个不重复的有序序列中，查找某一个数出现的位置很好查找，
但是如果是一个重复的有序序列中，查找某一个数第一次出现的位置，和最后一次出现的位置，该如何查找呢？
举个例子：
在 [1 2 3 3 4 5] 中查找元素3第一次出现的位置，和最后一次出现的位置

2. 算法思想

例：在 [1 2 2 3 3 4 5] 中查找元素3第一次出现的位置，和最后一次出现的位置.
左下标：L=0（1）
右下标：R=6（5）
中间下标：mid=3（3）

（1）查找3的起始位置（左边界）

定义一个性质 "大于等于3"，数组左边的所有数[L，3)都不满足这个性质，那么数组右边的所有数[3, R]都满足这个性质。
所以我们要查找的起始位置就是满足这个性质的左边界。

如果 q[mid] >= 3，那么说明mid一定是在3的右半边，并且数组右边的所有数[3, R]都满足这个性质。
此时【起始位置】应该是以mid为分界点，在mid的左半边，所以R应该等于mid，与此同时区间更新为：[L, mid]
因为mid是大于等于3的，那么mid位置可能会是答案，所以mid可以取到.

举个例子：比如在[1 2 2 3 4 4 5]中，要查询2，但是中间值q[mid]是3，比2大（q[mid]>=2）
那么要找的数字就在q[mid]的左边，所以就让R等于mid把区间缩小
数组：[1 2 2 3 3 4 5]
符号： L    mid    R
缩小： L     R

------------------------------------------

如果 q[mid] < 3，那么说明mid一定是在3的左半边，但是数组左边的所有数[L，3)都不满足这个性质。
此时【起始位置】应该是以mid为分界点，在mid的右半边，所以L应该等于mid+1，与此同时区间更新为：[mid+1, R]
因为mid是小于3的，那么mid位置一定不会是答案，所以要+1

举个例子：比如在[1 2 2 3 4 4 5]中，要查询4，但是中间值q[mid]是3，比4小（q[mid]<4）
那么要找的数字就在q[mid]的右边，所以就让L等于mid+1把区间缩小
数组：[1 2 2 3 3 4 5]
符号： L    mid    R
缩小：         L   R

当while循环结束以后，L和R是相等的，那么最后，L和R指向的下标位置就是3的起始下标位置
 

------------------------------------------


######################################################################################################################

（2）判断元素不存在的情况

如果我们要查找元素8第一次出现的位置，和最后一次出现的位置.
那么元素8很明显不存在数组中，那么我们二分出来的这个值就是：数组里面满足大于等于8的，最小的那个数，
也就从左往右看，第一个满足大于等于8的那个数。


######################################################################################################################


（3）查找3的终止位置（右边界）

定义一个性质 "小于等于3"，那么数组左边的所有数[L, 3]都满足这个性质，数组右边的所有数(3, R]都不满足这个性质
所以我们要查找的终止位置就是满足这个性质的右边界。

如果 q[mid] <= 3，那么mid一定是在3的左半边，并且数组左边的所有数[L, 3]满足性质的。
此时【终止位置】应该是以mid为分界点，在mid的右半边，所以L应该等于mid，与此同时更新区间为：[mid, R]
因为mid是小于等于3的，那么mid的位置可能会是答案，所以mid可以取到.

举个例子：比如在[1 2 2 3 4 4 5]中，要查询4，但是中间值q[mid]是3，比4小（q[mid]<=4）
那么要找的数字就在q[mid]的右边，所以就让L等于mid把区间缩小
数组：[1 2 2 3 3 4 5]
符号： L    mid    R
缩小：       L     R

------------------------------------------

如果 q[mid] > 3，那么mid一定是在3的右半边，但是数组右边的所有数(3, R]是不满足性质的。
此时【终止位置】应该是以mid为分界点，在mid的左半边，所以R应该等于mid-1，与此同时更新区间为：[L, mid-1]
因为mid是大于3的，那么mid位置一定不会是答案，所以要-1

举个例子：比如在[1 2 2 3 4 4 5]中，要查询2，但是中间值q[mid]是3，比2大（q[mid]>2）
那么要找的数字就在q[mid]的左边，所以就让R等于mid-1把区间缩小
数组：[1 2 2 3 3 4 5]
符号： L    mid    R
缩小： L   R


当while循环结束以后，L和R是相等的，那么最后，L和R指向的下标位置就是3的起始下标位置

4. 思考

为什么要写两种情况？，一般的题只写一种不就够了吗！
因为有边界限制，如果你输入的序列含有重复数字，你使用俩个代码查找的数字是一样的，但是下标不同。 
也就是说：查找的是相同的值，但不是同一个下标！

一般二分应用于无非下面这四种情况:
（1）找大于等于x的第一个位置 （满足某个条件的第一个数）
（2）找小于等于x的最后一个数 （满足某个条件的最后一个数）
（3）查找最大值 （满足该边界的右边界）
（4）查找最小值 (满足该边界的左边界)
*/

#include <iostream>
using namespace std;

const int N = 1e5+10;

int n, m;
int q[N];

int main()
{
    //
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    //
    
    cin >> n >> m;
    for (int i = 0; i < n; i++ ) cin >> q[i];
    
    //查找m次
    while (m --)
    {
        //输入要查找的值
        int x;
        cin >> x;
        
        //1.定义一个 "大于等于x" 的性质，在性质内查找【左边界】
        int l = 0, r = n - 1;
        while (l < r)
        {
            int mid = (l + r) >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        
        //2.查找的x不存在
        if (q[l] != x)
            cout << "-1 -1" << endl;
        else {
            cout << l << " "; //输出x第一次出现的位置
            
            //3.定义一个 "小于等于x" 的性质，在性质内查找【右边界】
            int l = 0, r = n - 1;
            while (l < r)
            {
                int mid = (l + r + 1) >> 1;
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << l << endl; //输出x最后一次出现的位置
        }
    }
    
    return 0;
}