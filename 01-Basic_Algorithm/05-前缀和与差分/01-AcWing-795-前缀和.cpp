/*
题目链接：https://www.acwing.com/problem/content/797/

1.题目描述

输入一个长度为 n 的整数序列，返回其中任意范围之间的和

举个例子，假设我现在输入：2 1 3 6 4
第 1 个数和第 2 个数之间的和为：2+1=3
第 1 个数和第 3 个数之间的和为：2+1+3=6
第 2 个数和第 4 个数之间的和为：1+3+6=10

2.算法思路

假设现在有 n 个数的整数序列：a1 a2 a3 ... an
那么前 i 个数的和为：S[i] = a[1] + a[2] + ... + a[i]
其实写成递推的话，就是：S[i] = S[i-1] + a[i]，也就是前[i-1]个数的和 加上 第[i]个数的和
并且 i 要从 1 开始循环，然后S[0]的初始值要设置为0

但是，如何求一段区间 [l ,r] 之间的和呢？
假设我现在输入：2 1 3 6 4，求第 2 个数和第 4 个数之间的和
S[2, 4] = (2+1+3+6) - (2)
        = 10
        = S[4] - S[2-1]
我们通过观察可以得到一个公式：S[l, r] = S[r] - S[l - 1];

当我们把公式展开以后：
S[r] = a1 + a2 + a3 + ... + al-1 + al + ... + ar
S[l-1] = a1 + a2 + a3 + ... + al-1
S[r] - S[l-1] = al + ... + ar
所以可以发现区间 [l ,r] 之间的和，就是从第 l 个数开始一直加到第 r 个数！

那么我们为什么要让 S[0] = 0 呢？
因为当我们要计算区间[1, 10] 之间的和，利用公式就是：S[10] - S[1 - 1] = S[10] - S[0] = S[10]
区间[1, 10] 之间的和就是从第 1 个数开始，一直加到第 10 个数。
如果S[0]不默认给0的话，就不能适用于所有情况

*/

#include <iostream>
using namespace std;

const int N = 1e5+10;

int n, m;
int a[N]; // 输入的数组
int s[N]; // 前缀和的数组

//注意：当数组定义为全局变量以后，那么默认的初始值就是0

int main()
{
    //关流：优点是提高 cin>> 的读取速度，缺点是不能再使用 scanf() 
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    ios_base::sync_with_stdio(false);
    //
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++ ) // 从下标1开始存储数据，并且a[0]默认值为0
        cin >> a[i];
    
    for (int i = 1; i <= n; i++ ) // 计算数组a的前i个数的和，并存入s数组中
        s[i] = s[i - 1] + a[i]; // 当i=1时，s[1] = s[0] + a[i]，并且s[0]默认值为0
        
    while (m --) // m次询问
    {
        int l, r; // 区间[l, r]
        cin >> l >> r;
        cout << s[r] - s[l - 1] << endl; // 输出区间[l, r]之间的和
    }
    return 0;
}
